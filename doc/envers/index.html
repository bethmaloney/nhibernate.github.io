<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>NHibernate Envers - Audit trail for NHibernate</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>NHibernate Envers - Audit trail for NHibernate</h1></div><div><h2 class="subtitle">NHibernate Envers Reference Documentation</h2></div><div><p class="releaseinfo">5.2</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#quickstart">1. Quickstart</a></span></dt><dt><span class="chapter"><a href="#example">2. Short example</a></span></dt><dt><span class="chapter"><a href="#configuration">3. Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#config-basics">3.1. Basic configuration</a></span></dt><dt><span class="section"><a href="#config-audit-strategy">3.2. Choosing an audit strategy</a></span></dt><dt><span class="section"><a href="#config-reference">3.3. Reference</a></span></dt><dt><span class="section"><a href="#d0e361">3.4. Additional mapping annotations</a></span></dt></dl></dd><dt><span class="chapter"><a href="#revisionlog">4. Logging data for revisions</a></span></dt><dd><dl><dt><span class="section"><a href="#envers-tracking-modified-entities-revchanges">4.1. Tracking entity names modified during revisions</a></span></dt><dt><span class="section"><a href="#envers-tracking-properties-changes">4.2. Tracking entity changes at property level</a></span></dt></dl></dd><dt><span class="chapter"><a href="#queries">5. Queries</a></span></dt><dd><dl><dt><span class="section"><a href="#entities-at-revision">5.1. Querying for entities of a class at a given revision</a></span></dt><dt><span class="section"><a href="#revisions-of-entity">5.2. Querying for revisions, at which entities of a given class changed</a></span></dt><dt><span class="section"><a href="#envers-envers-tracking-properties-changes-queries">5.3. Querying for revisions of entity that modified given property</a></span></dt><dt><span class="section"><a href="#envers-tracking-modified-entities-queries">5.4. Querying for entities modified in a given revision</a></span></dt><dt><span class="section"><a href="#session-extension-method">5.5. 
			Auditer(), an extension method on ISession
		</a></span></dt></dl></dd><dt><span class="chapter"><a href="#schema">6. Database schema</a></span></dt><dt><span class="chapter"><a href="#tables">7. Generated tables and their content</a></span></dt><dt><span class="chapter"><a href="#source">8. Building from source and testing</a></span></dt><dt><span class="chapter"><a href="#exceptions">9. Mapping exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="#exceptions-wontbesupported">9.1. What is not and will (probably) not be supported</a></span></dt><dt><span class="section"><a href="#exceptions-willbesupported">9.2. What is not but will be supported</a></span></dt></dl></dd><dt><span class="chapter"><a href="#links">10. Links</a></span></dt></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div><div></div></div><p>
		The Envers project aims to enable easy auditing of persistent classes. All that you
		have to do is to configure Envers to audit some of your persistent classes.
		For each audited entity, a table will be created which will hold the history of changes made to the entity. You
		can then retrieve and query historical data without much effort.
	</p><p>
		Similarly to source control systems, the library has a concept of revisions. Basically, one
		transaction is one revision (unless the transaction didn't modify any audited entities).
		As the revisions are global and having a revision number, you can query for various
		entities at that revision, retrieving a (partial) view of the database at that
		revision. You can find a revision number having a date, and the other way round,
		you can get the date at which a revision was commited.
	</p><p>
		The library works with NHibernate version 3.1 or later.
		For the auditing to work properly, the entities must have immutable unique
		identifiers (primary keys).
	</p><p>
		Some of the features:
	</p><div class="orderedlist"><ol type="1"><li><p>
				Auditing of all NHibernate mappings
			</p></li><li><p>
				Auditing custom types and collections/maps of "simple" types (strings, integers, etc.)
				(see also <a href="#exceptions" title="Chapter&nbsp;9.&nbsp;Mapping exceptions">Chapter&nbsp;9, <i>Mapping exceptions</i></a>)
			</p></li><li><p>
				Logging data for each revision using a "revision entity"
			</p></li><li><p>
				Querying historical data
			</p></li></ol></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="quickstart"></a>Chapter&nbsp;1.&nbsp;Quickstart</h2></div></div><div></div></div><p>
		Out of the box there are two ways to configure Envers,
		by attributes or by code (fluent).
	</p><p>
		Simple attribute configuration
	</p><pre class="programlisting">nhConf.IntegrateWithEnvers(new AttributeConfiguration());
[...]

[Audited]
public class Person
[...]</pre><p>
		Simple fluent configuration
	</p><pre class="programlisting">var enversConf = new FluentConfiguration();
enversConf.Audit&lt;Person&gt;();
nhConf.IntegrateWithEnvers(enversConf);</pre><p>
		And that's it! You create, modify and delete the entites as always. If you look
		at the generated schema, you will notice that current schema is unchanged.
		Also, the data they hold is the same. There are,
		however, new tables which store the historical data whenever you commit a transaction.
	</p><p>
		Instead of annotating the whole class and auditing all properties, you can annotate
		only some persistent properties with <tt class="literal">[Audited]</tt> (attributes)
		or use "Exclude" method to exclude non audited properties (fluent).
	</p><p>
		You can access the audit (history) of an entity using the <tt class="literal">IAuditReader</tt> interface, which you
		can obtain when having an open <tt class="literal">ISession</tt>.
	</p><pre class="programlisting">var reader = AuditReaderFactory.Get(session);
var oldPerson = reader.Find(typeof(Person), personId, revision);</pre><p>
		The <tt class="literal">T Find&lt;T&gt;(object primaryKey, long revision)</tt>
		method returns an entity with the given primary key, with the data it contained at
		the given revision. If the entity didn't exist at that revision, <tt class="literal">null</tt>
		is returned. Only the audited properties will be set on the returned entity.
		The rest will be <tt class="literal">null</tt>.
	</p><p>
		You can also get a list of revisions at which an entity was modified using the
		<tt class="literal">GetRevisions</tt> method, as well as retrieve the date,
		at which a revision was created using the <tt class="literal">GetRevisionDate</tt> method.
	</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="example"></a>Chapter&nbsp;2.&nbsp;Short example</h2></div></div><div></div></div><p>
		For example, using the entities defined above, the following code will generate
		revision number 1, which will contain two new <tt class="literal">Person</tt> and
		two new <tt class="literal">Address</tt> entities:
	</p><pre class="programlisting">using(var tx = session.BeginTransaction())
{
	var address1 = new Address("Privet Drive", 4);
	var person1 = new Person("Harry", "Potter", address1);

	var address2 = new Address("Grimmauld Place", 12);
	var person2 = new Person("Hermione", "Granger", address2);

	session.Save(address1);
	session.Save(address2);
	session.Save(person1);
	session.Save(person2);

	tx.Commit();
}</pre><p>
		Now we change some entities. This will generate revision number 2, which will contain
		modifications of one person entity and two address entities (as the collection of
		persons living at <tt class="literal">address2</tt> and <tt class="literal">address1</tt> changes):
	</p><pre class="programlisting">using(var tx = session.BeginTransaction())
{
	var address1 = session.Get&lt;Address&gt;(address1.Id);
	var person2 = session.Get&lt;Person&gt;(person2.Id);

	// Changing the address's house number
	address1.setHouseNumber(5)

	// And moving Hermione to Harry
	person2.setAddress(address1);

	tx.Commit();
}</pre><p>
		We can retrieve the old versions (the audit) easily:
	</p><pre class="programlisting">var reader = AuditReaderFactory.Get(session);

var person2_rev1 = reader.Find&amp;lt;Person&amp;gt;(person2.Id, 1);
Assert.AreEqual(person2_rev1.Address, new Address("Grimmauld Place", 12));

var address1_rev1 = reader.Find&amp;lt;Address&amp;gt;(address1.Id, 1);
Assert.AreEqual(address1_rev1.Persons.Count, 1);
		
// and so on</pre></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="configuration"></a>Chapter&nbsp;3.&nbsp;Configuration</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="config-basics"></a>3.1.&nbsp;Basic configuration</h2></div></div><div></div></div><p>
			To start working with Envers, all configuration needed is to call
			the extension method IntegrateWithEnvers() on the NH Configuration object,
			as described in the <a href="#quickstart" title="Chapter&nbsp;1.&nbsp;Quickstart">Chapter&nbsp;1, <i>Quickstart</i></a>.
		</p><p>
			However, as Envers generates some entities and maps them to tables, it is possible to set the prefix and suffix
			that is added to the entity name to create an audit table for an entity, as well
			as set the names of the fields that are generated.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="config-audit-strategy"></a>3.2.&nbsp;Choosing an audit strategy</h2></div></div><div></div></div><p>
			After the basic configuration it is important to choose the audit strategy that will be used to persist and
			retrieve audit information. There is a trade-off between the performance of persisting and the performance
			of querying the audit information. Currently there two audit strategies:

			</p><div class="orderedlist"><ol type="1"><li><p>
						The default audit strategy persists the audit data together with a start revision. For each row
						inserted, updated or deleted in an audited table, one or more rows are inserted in the audit tables,
						together with the start revision of its validity. Rows in the audit tables are never updated after insertion.
						Queries of audit information use subqueries to select the applicable rows in the audit tables.
						These subqueries are notoriously slow and difficult to index.
					</p></li><li><p>
						The alternative is a validity audit strategy. This strategy stores the start-revision and the end-revision
						of audit information. For each row inserted, updated or deleted in an audited table, one or more rows
						are inserted in the audit tables, together with the start revision of its validity. But at the same time
						the end-revision field of the previous audit rows (if available) are set to this revision.
						Queries on the audit information can then use 'between start and end revision' instead of subqueries
						as used by the default audit strategy.
						The consequence of this strategy is that persisting audit information will be a bit slower, because of the
						extra updates involved, but retrieving audit information will be a lot faster. This can be improved by
						adding extra indexes.
					</p></li></ol></div><p>
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="config-reference"></a>3.3.&nbsp;Reference</h2></div></div><div></div></div><p>
			There are three ways setting property values. All examples below produce the same result
			(tells Envers to store entity data at delete).
		</p><pre class="programlisting">//NHibernate Core syntax
nhConf.SetProperty("nhibernate.envers.store_data_at_delete", "true");

//Using SetEnversProperty extension method with type safe value input
nhConf.SetEnversProperty(ConfigurationKey.StoreDataAtDelete, true);

//Using ConfigurationKey directly with type safe value input
ConfigurationKey.StoreDataAtDelete.SetUserValue(nhConfiguration, true);
		</pre><p>
			In more detail, below are the properties that you can pass to NHibernate.Cfg.Configuration.
			The property names are, from code, also available on ConfigurationKey class.
		</p><div class="table"><a name="d0e146"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Envers Configuration Properties</b></p><table summary="Envers Configuration Properties" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>
							Property name
						</th><th>Default value</th><th>Description</th></tr></thead><tbody><tr><td>
							nhibernate.envers.audit_table_prefix
						</td><td>&nbsp;</td><td>
							String that will be prepended to the name of an audited entity to create
							the name of the entity, that will hold audit information.
						</td></tr><tr><td>
							nhibernate.envers.audit_table_suffix
						</td><td>
							_AUD
						</td><td>
							String that will be appended to the name of an audited entity to create
							the name of the entity, that will hold audit information. If you
							audit an entity with a table name Person, in the default setting Envers
							will generate a <tt class="literal">Person_AUD</tt> table to store historical data.
						</td></tr><tr><td>
							nhibernate.envers.revision_field_name
						</td><td>
							REV
						</td><td>
							Name of a field in the audit entity that will hold the revision number.
						</td></tr><tr><td>
							nhibernate.envers.revision_type_field_name
						</td><td>
							REVTYPE
						</td><td>
							Name of a field in the audit entity that will hold the type of the
							revision (currently, this can be: add, mod, del).
						</td></tr><tr><td>
							nhibernate.envers.revision_on_collection_change
						</td><td>
							true
						</td><td>
							Should a revision be generated when a not-owned relation field changes
							(this can be either a collection in a one-to-many relation, or the field
							using "mappedBy" attribute in a one-to-one relation).
						</td></tr><tr><td>
							nhibernate.envers.do_not_audit_optimistic_locking_field
						</td><td>
							true
						</td><td>
							When true, properties to be used for optimistic locking will be automatically not audited
							(their history won't be stored; it normally doesn't make sense to store it).
						</td></tr><tr><td>
							nhibernate.envers.store_data_at_delete
						</td><td>
							false
						</td><td>
							Should the entity data be stored in the revision when the entity is deleted (instead of only
							storing the id and all other properties as null). This is normally not needed, as the data is
							present in the last-but-one revision. Sometimes, however, it is easier and more efficient to
							access it in the last revision (then the data that the entity contained before deletion is
							stored twice).
						</td></tr><tr><td>
							nhibernate.envers.default_schema
						</td><td>
							null (same as normal tables)
						</td><td>
							The default schema name that should be used for audit tables. Can be overriden using the
							<tt class="literal">[AuditTable(schema="...")]</tt> attribute. If not present, the schema will
							be the same as the schema of the normal tables.
						</td></tr><tr><td>
							nhibernate.envers.default_catalog
						</td><td>
							null (same as normal tables)
						</td><td>
							The default catalog name that should be used for audit tables. Can be overriden using the
							<tt class="literal">[AuditTable(catalog="...")]</tt> attribute. If not present, the catalog will
							be the same as the catalog of the normal tables.
						</td></tr><tr><td>
							nhibernate.envers.audit_strategy
						</td><td>
							NHibernate.Envers.Strategy.DefaultAuditStrategy
						</td><td>
							The audit strategy that should be used when persisting audit data. The default stores only the
							revision, at which an entity was modified. An alternative, the
							<tt class="literal">NHibernate.Envers.Strategy.ValidityAuditStrategy</tt> stores both the
							start revision and the end revision. Together these define when an audit row was valid, hence
							the name ValidityAuditStrategy.
						</td></tr><tr><td>
							nhibernate.envers.audit_strategy_validity_end_rev_field_name
						</td><td>
							REVEND
						</td><td>
							The column name that will hold the end revision number in audit entities. This property is only
							valid if the validity audit strategy is used.
						</td></tr><tr><td>
							nhibernate.envers.audit_strategy_validity_store_revend_timestamp
						</td><td>
							false
						</td><td>
							Should the timestamp of the end revision be stored, until which the data was valid, in addition to the end revision itself.
							This is useful to be able to purge old Audit records out of a relational database by using table partitioning.
							Partitioning requires a column that exists within the table.
							This property is only evaluated if the ValidityAuditStrategy is used.
						</td></tr><tr><td>
							nhibernate.envers.audit_strategy_validity_revend_timestamp_field_name
						</td><td>
							REVEND_TSTMP
						</td><td>
							Column name of the timestamp of the end revision until which the data was valid.
							Only used if the ValidityAuditStrategy is used, and
							nhibernate.envers.audit_strategy_validity_store_revend_timestamp evaluates to true
						</td></tr><tr><td>
							nhibernate.envers.track_entities_changed_in_revision
						</td><td>
							false
						</td><td>
							Should entity types, that have been modified during each revision, be tracked. The default
							implementation creates <tt class="literal">REVCHANGES</tt> table that stores entity names
							of modified persistent objects. Single record encapsulates the revision identifier
							(foreign key to <tt class="literal">REVINFO</tt> table) and a string value. For more
							information refer to <a href="#envers-tracking-modified-entities-revchanges" title="4.1.&nbsp;Tracking entity names modified during revisions">Section&nbsp;4.1, &#8220;Tracking entity names modified during revisions&#8221;</a>
							and <a href="#envers-tracking-modified-entities-queries" title="5.4.&nbsp;Querying for entities modified in a given revision">Section&nbsp;5.4, &#8220;Querying for entities modified in a given revision&#8221;</a>.
						</td></tr><tr><td>
							nhibernate.envers.global_with_modified_flag
						</td><td>
							false, can be individually overriden with <tt class="literal">[Audited(WithModifiedFlag=true)]</tt></td><td>
							Should property modification flags be stored for all audited entities and all properties.
							When set to true, for all properties an additional boolean column in the audit tables will
							be created, filled with information if the given property changed in the given revision.
							When set to false, such column can be added to selected entities or properties using the
							<tt class="literal">[Audited]</tt> attribute.
							For more information refer to <a href="#envers-tracking-properties-changes" title="4.2.&nbsp;Tracking entity changes at property level">Section&nbsp;4.2, &#8220;Tracking entity changes at property level&#8221;</a>
							and <a href="#envers-envers-tracking-properties-changes-queries" title="5.3.&nbsp;Querying for revisions of entity that modified given property">Section&nbsp;5.3, &#8220;Querying for revisions of entity that modified given property&#8221;</a>.
						</td></tr><tr><td>
							nhibernate.envers.modified_flag_suffix
						</td><td>
							_MOD
						</td><td>
							The suffix for columns storing "Modified Flags".
							For example: a property called "age", will by default get modified flag with column name "age_MOD".
						</td></tr><tr><td>
							nhibernate.envers.embeddable_set_ordinal_field_name
						</td><td>
							SETORDINAL
						</td><td>
							Name of column used for storing ordinal of the change in sets of embeddable elements.
						</td></tr><tr><td>
							nhibernate.envers.allow_identifier_reuse
						</td><td>
							false
						</td><td>
							Guarantees proper validity audit strategy behavior when application reuses identifiers
							of deleted entities. Exactly one row with <tt class="literal">null</tt> end date exists
							for each identifier.
						</td></tr><tr><td>
							nhibernate.envers.collection_mapper_factory
						</td><td>
							NHibernate.Envers.Configuration.Metadata.DefaultCollectionMapperFactory
						</td><td>
							Responsible to create collection mappers for audited entities.
							May be used if NHibernate Core isn't using its normal types for its mapped collections,
							eg if a user defined CollectionTypeFactory is used.
						</td></tr><tr><td>
							nhibernate.envers.post_instantiation_listener
						</td><td>
							NHibernate.Envers.Configuration.Metadata.DefaultEnversPostInstantiationListener
						</td><td>
							Each audited entity will be sent to IPostInstantiationListener immediately after it has been instantiated and populated.
							May be used to inject dependencies for the entity.
						</td></tr><tr><td>
							nhibernate.envers.table_name_strategy
						</td><td>
							NHibernate.Envers.Configuration.DefaultNamingStrategy
						</td><td>
							Give names to envers auditing tables. Either implement your own <tt class="literal">NHibernate.Envers.Configuration.IEnversNamingStrategy</tt> or
							subclass <tt class="literal">NHibernate.Envers.Configuration.DefaultNamingStrategy</tt>.
							Note that your implementation will override <tt class="literal">nhibernate.envers.audit_table_prefix</tt> and
							<tt class="literal">nhibernate.envers.audit_table_suffix</tt> settings.
							Your explicit table names (both when using attribute configuration and fluent configuration) will still be valid though.
						</td></tr><tr><td>
							nhibernate.envers.unique_cfg_name
						</td><td>
							A guid string
						</td><td>
							A unique name for the configuration object. Used internally by Envers. Must not be set explicitly by user!
						</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e361"></a>3.4.&nbsp;Additional mapping annotations</h2></div></div><div></div></div><p>
			To set the value of any of the properties described above, simply add an entry to
			your NHibernate Core's <tt class="literal">Configuration</tt> object.
		</p><p>
			To change the name of the revision table and its fields (the table, in which the
			numbers of revisions and their timestamps are stored), you can use the
			<tt class="literal">[RevisionEntity]</tt> attribute.
			For more information, see <a href="#revisionlog" title="Chapter&nbsp;4.&nbsp;Logging data for revisions">Chapter&nbsp;4, <i>Logging data for revisions</i></a>.
		</p><p>
			The name of the audit table can be set on a per-entity basis, using the <tt class="literal">AuditTableAttribute</tt> (attribute) or <tt class="literal">SetTableInfo()</tt> (fluent).
			It may be tedious to add this annotation to every audited entity, so if possible, it's better to use a prefix/suffix.
			As an alternative, you can create your own <tt class="literal">nhibernate.envers.table_name_strategy</tt> to set table names.
		</p><p>
			If you have a mapping with join tables, audit tables for them will be generated in
			the same way (by adding the prefix and suffix). If you wish to overwrite this behaviour,
			you can use the <tt class="literal">[JoinAuditTable]</tt> attribute.
		</p><p>
			If you'd like to override auditing behaviour of some fields/properties inherited from
			a non mapped base type or in an embedded component, you can apply the <tt class="literal">[AuditOverride]</tt>
			attribute on the subtype or usage site of the component.
		</p><p>
			If you want to audit a relation, where the target entity is not audited (that is the case for example with
			dictionary-like entities, which don't change and don't have to be audited), just annotate it with
			<tt class="literal">[Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED]</tt>
			(or use fluent configuration: <tt class="literal">ExcludeRelationData()</tt>). Then, when reading historic
			versions of your entity, the relation will always point to the "current" related entity.
			By default Envers throws  when "current" entity does not exist in the database.
			Apply <tt class="literal">not-found="ignore"</tt> in your mapping
			to silence the exception and assign null value instead. Hereby solution causes implicit eager loading
			of to-one relations.
		</p><p>
			If you'd like to audit properties of a superclass of an entity, which are not explicitly audited (which
			don't have the <tt class="literal">AuditedAttribute</tt> on any properties or on the class),
			use <tt class="literal">[AuditOverride(ForClass = typeof(SomeEntity), IsAudited = true/false)]</tt>.
		</p><p>
			If an audited entity should be created by a factory, annotate the entity with the <tt class="literal">[AuditFactory(typeof(SomeFactory))]</tt>
			attribute to specify the factory type.  You can also pass an pre-configured instance into the fluent interface's <tt class="literal">UseFactory()</tt>.
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="revisionlog"></a>Chapter&nbsp;4.&nbsp;Logging data for revisions</h2></div></div><div></div></div><p>
		Envers provides an easy way to log additional data for each revision. You simply need
		to annotate one entity with <tt class="literal">[RevisionEntity]</tt> (attribute) or <tt class="literal">SetRevisionEntity</tt> (fluent),
		and a new instance of this entity will be persisted when a new revision is created (that is, whenever an
		audited entity is modified). As revisions are global, you can have at most one revisions entity.
	</p><p>
		Please note that the revision entity must be a mapped Hibernate entity.
	</p><p>
		This entity must have at least two properties:
	</p><div class="orderedlist"><ol type="1"><li><p>
				An integer- or long-valued property, annotated with <tt class="literal">[RevisionNumber]</tt>. Most
				often, this will be an auto-generated primary key.
			</p></li><li><p>
				A long- or date-valued property, annotated with <tt class="literal">[RevisionTimestamp]</tt>. Value of
				this property will be automatically set by Envers.
			</p></li></ol></div><p>
		You can either add these properties to your entity, or extend
		<tt class="literal">DefaultRevisionEntity</tt>, which already has those two properties.
	</p><p>
		To fill the entity with additional data, you'll need to implement the
		<tt class="literal">IRevisionListener</tt> interface. Its newRevision method will
		be called when a new revision is created, before persisting the revision entity.
		The implementation should be stateless and thread-safe. The listener then has to be
		attached to the revisions entity by specifying it as a parameter to the
		<tt class="literal">[RevisionEntity]</tt> attribute.
	</p><p>
		Alternatively, you can use the <tt class="literal">GetCurrentRevision</tt> method of the
		<tt class="literal">AuditReader</tt> interface to obtain the current revision, and fill it with desired information.
		The method has a <tt class="literal">persist</tt> parameter specifying, if the revision entity should be persisted
		before returning. If set to <tt class="literal">true</tt>, the revision number will be available in the returned
		revision entity (as it is normally generated by the database), but the revision entity will be persisted
		regardless of wheter there are any audited entities changed. If set to <tt class="literal">false</tt>, the revision
		number will be <tt class="literal">null</tt>, but the revision entity will be persisted only if some audited entities
		have changed.
	</p><p>
		A simplest example of a revisions entity, which with each revision associates the
		username of the user making the change is:
	</p><pre class="programlisting">[Entity]
[RevisionEntity(typeof(ExampleListener))]
public class ExampleRevEntity : DefaultRevisionEntity
{
	public virtual string UserName {get;set;}
}</pre><p>
		Or, if you don't want to extend any class:
	</p><pre class="programlisting">[Entity]
[RevisionEntity(typeof(ExampleListener))]
public class ExampleRevEntity
{
	[RevisionNumber]
	public virtual int Id { get; set; }

	[RevisionTimestamp]
	public virtual long Timestamp { get; set; }

	public virtual string UserName { get; set; }

	// Equals, GetHashCode ...
}</pre><p>
		Having an "empty" revision entity - that is, with no additional properties except the
		two mandatory ones - is also an easy way to change the names of the table and of the
		properties in the revisions table automatically generated by Envers.
	</p><p>
		In case there is no entity annotated with <tt class="literal">[RevisionEntity]</tt>, a default
		table will be generated, with the name <tt class="literal">REVINFO</tt>.
	</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="envers-tracking-modified-entities-revchanges"></a>4.1.&nbsp;Tracking entity names modified during revisions</h2></div></div><div></div></div><p>
			By default entity types that have been changed in each revision are not being tracked. This implies the
			necessity to query all tables storing audited data in order to retrieve changes made during
			specified revision. Envers provides a simple mechanism that creates <tt class="literal">REVCHANGES</tt>
			table which stores entity names of modified persistent objects. Single record encapsulates the revision
			identifier (foreign key to <tt class="literal">REVINFO</tt> table) and a string value.
		</p><p>
			Tracking of modified entity names can be enabled in three different ways:
		</p><div class="orderedlist"><ol type="1"><li>
				Set <span class="property">nhibernate.envers.track_entities_changed_in_revision</span> parameter to
				<tt class="literal">true</tt>. In this case
				<tt class="classname">NHibernate.Envers.DefaultTrackingModifiedEntitiesRevisionEntity</tt> will
				be implicitly used as the revision log entity.
			</li><li>
				Create a custom revision entity that extends
				<tt class="classname">NHibernate.Envers.DefaultTrackingModifiedEntitiesRevisionEntity</tt> class.
				<pre class="programlisting">[RevisionEntity]
public class ExtendedRevisionEntity : DefaultTrackingModifiedEntitiesRevisionEntity 
{
	 ...
}</pre></li><li>
				Mark an appropriate field of a custom revision entity with
				<tt class="interfacename">NHibernate.Envers.ModifiedEntityNames</tt> annotation. The property is
				required to be of <tt class="literal">ISet&lt;string&gt;</tt> type.
				<pre class="programlisting">[RevisionEntity]
public class AnnotatedTrackingRevisionEntity 
{
	...
	
	[ModifiedEntityNames]
	private Set&lt;String&gt; modifiedEntityNames;
		 
	...
}</pre></li></ol></div><p>
			Users, that have chosen one of the approaches listed above, can retrieve all entities modified in a
			specified revision by utilizing API described in <a href="#envers-tracking-modified-entities-queries" title="5.4.&nbsp;Querying for entities modified in a given revision">Section&nbsp;5.4, &#8220;Querying for entities modified in a given revision&#8221;</a>.
		</p><p>
			Users are also allowed to implement custom mechanism of tracking modified entity types. In this case, they
			shall pass their own implementation of
			<tt class="interfacename">IEntityTrackingRevisionListener</tt> interface as the value
			of <tt class="code">RevisionEntityAttribute</tt> annotation.
			<tt class="interfacename">IEntityTrackingRevisionListener</tt> interface exposes one method that notifies
			whenever audited entity instance has been added, modified or removed within current revision boundaries.
		</p><div class="example"><a name="d0e560"></a><p class="title"><b>Example&nbsp;4.1.&nbsp;Custom implementation of tracking entity classes modified during revisions</b></p><pre class="programlisting"><tt class="filename">CustomEntityTrackingRevisionListener.cs</tt>
public class CustomEntityTrackingRevisionListener 
	: IEntityTrackingRevisionListener 
{
	public void EntityChanged(Type entityClass, string entityName, object entityId, 
		RevisionType revisionType, object revisionEntity) 
	{
		((CustomTrackingRevisionEntity)revisionEntity)
			.AddModifiedEntityName(entityClass.FullName);
	}
	
	public void newRevision(object revisionEntity) 
	{
	}
}</pre><pre class="programlisting"><tt class="filename">CustomTrackingRevisionEntity.cs</tt>
[RevisionEntity(typeof(CustomEntityTrackingRevisionListener))
public class CustomTrackingRevisionEntity 
{
	private int customId;
	
	[RevisionTimestamp]
	private long customTimestamp;
	
	private ISet&lt;ModifiedEntityTypeEntity&gt; modifiedEntityTypes 
						= new HashSet&lt;ModifiedEntityTypeEntity&gt;();
		 
	public void addModifiedEntityType(string entityName) 
	{
		modifiedEntityTypes.add(new ModifiedEntityTypesEntity(this, entityName));
	}
	
	public void removeModifiedEntityType(string entityName) 
	{
		modifiedEntityTypes.remove(new ModifiedEntityTypeEntity(this, entityName));
	}
		 
	...
}</pre><pre class="programlisting"><tt class="filename">ModifiedEntityNameEntity.cs</tt>
public class ModifiedEntityTypeEntity 
{
	private Integer id;
	
	private CustomTrackingRevisionEntity revision;
		 
	private string entityName;
		 
	...
}</pre><pre class="programlisting">var revEntity = AuditReader()
	.FindRevision(typeof(CustomTrackingRevisionEntity), revisionNumber);
var modifiedEntityTypes = revEntity.ModifiedEntityNames</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="envers-tracking-properties-changes"></a>4.2.&nbsp;Tracking entity changes at property level</h2></div></div><div></div></div><p>
			By default the only information stored by Envers are revisions of modified entities.
			This approach lets user create audit queries based on historical values of entity's properties.

			Sometimes it is useful to store additional metadata for each revision, when you are interested also in
			the type of changes, not only about the resulting values. The feature described in
			<a href="#envers-tracking-modified-entities-revchanges" title="4.1.&nbsp;Tracking entity names modified during revisions">Section&nbsp;4.1, &#8220;Tracking entity names modified during revisions&#8221;</a>
			makes it possible to tell which entities were modified in given revision.

			Feature described here takes it one step further. "Modification Flags" enable Envers to track which
			properties of audited entities were modified in a given revision.
		</p><p>
			Tracking entity changes at property level can be enabled by:
		</p><div class="orderedlist"><ol type="1"><li>
				setting
				<span class="property">nhibernate.envers.global_with_modified_flag</span>
				configuration property to
				<tt class="literal">true</tt>.
				This global switch will cause adding modification flags for all audited
				properties in all audited entities.
			</li><li>
				using <tt class="literal">[Audited(WithModifiedFlag=true)]</tt>
				on a property or on an entity.
			</li></ol></div><p>
			The trade-off coming with this functionality is an increased size of
			audit tables and a very little, almost negligible, performance drop
			during audit writes. This is due to the fact that every tracked
			property has to have an accompanying boolean column in the
			schema that stores information about the property's modifications. Of
			course it is Envers' job to fill these columns accordingly - no additional work by the
			developer is required. Because of costs mentioned, it is recommended
			to enable the feature selectively, when needed with use of the
			granular configuration means described above.
		</p><p>
			To see how "Modified Flags" can be utilized, check out the very
			simple query API that uses them: <a href="#envers-envers-tracking-properties-changes-queries" title="5.3.&nbsp;Querying for revisions of entity that modified given property">Section&nbsp;5.3, &#8220;Querying for revisions of entity that modified given property&#8221;</a>.
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="queries"></a>Chapter&nbsp;5.&nbsp;Queries</h2></div></div><div></div></div><p>
		You can think of historic data as having two dimension. The first - horizontal -
		is the state of the database at a given revision. Thus, you can
		query for entities as they were at revision N. The second - vertical - are the
		revisions, at which entities changed. Hence, you can query for revisions,
		in which a given entity changed.
	</p><p>
		The queries in Envers are similar to
		<a href="http://www.nhforge.org/doc/nh/en/index.html#querycriteria" target="_top">NHibernate Criteria</a>,
		so if you are common with them, using Envers queries will be much easier.
	</p><p>
		Please note, that queries on the audited data are usually a lot slower
		than corresponding queries on "live" data, as they involve correlated subselects.
	</p><p>
		Queries will be improved both in terms of speed and possibilities, when using the valid-time
		audit strategy, that is when storing both start and end revisions for entities. See
		<a href="#configuration" title="Chapter&nbsp;3.&nbsp;Configuration">Chapter&nbsp;3, <i>Configuration</i></a>.
	</p><p>
		Experimental:
		You can traverse relations when querying using <tt class="code">TraverseRelation()</tt> and <tt class="code">Up()</tt>. Currently however,
		you can only traverse relations using inner joins.
	</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="entities-at-revision"></a>5.1.&nbsp;Querying for entities of a class at a given revision</h2></div></div><div></div></div><p>
			The entry point for this type of queries is:
		</p><pre class="programlisting">var query = AuditReader().CreateQuery()
	.ForEntitiesAtRevision(typeof(MyEntity, revisionNumber);</pre><p>
			You can then specify constraints, which should be met by the entities returned, by
			adding restrictions, which can be obtained using the <tt class="literal">AuditEntity</tt>
			factory class. For example, to select only entities, where the "name" property
			is equal to "John":
		</p><pre class="programlisting">query.Add(AuditEntity.Property("name").Eq("John"));</pre><p>
			And to select only entites that are related to a given entity:
		</p><pre class="programlisting">query.Add(AuditEntity.Property("address").Eq(relatedEntityInstance));
// or
query.Add(AuditEntity.RelatedId("address").Eq(relatedEntityId));</pre><p>
			You can limit the number of results, order them, and set aggregations and projections
			(except grouping) in the usual way.
			When your query is complete, you can obtain the results by calling the
			<tt class="literal">SingleResult()</tt> or <tt class="literal">ResultList()</tt> methods.
		</p><p>
			A full query, can look for example like this:
		</p><pre class="programlisting">var personsAtAddress = AuditReader().CreateQuery()
	 .ForEntitiesAtRevision(typeof(Person), 12)
	 .AddOrder(AuditEntity.Property("surname").Desc())
	 .Add(AuditEntity.RelatedId("address").Eq(addressId))
	 .SetFirstResult(4)
	 .SetMaxResults(2)
	 .GetResultList();</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="revisions-of-entity"></a>5.2.&nbsp;Querying for revisions, at which entities of a given class changed</h2></div></div><div></div></div><p>
			The entry point for this type of queries is:
		</p><pre class="programlisting">var query = AuditReader().CreateQuery()
	 .ForRevisionsOfEntity(typeof(MyEntity), false, true);</pre><p>
			You can add constraints to this query in the same way as to the previous one.
			There are some additional possibilities:
		</p><div class="orderedlist"><ol type="1"><li><p>
					Using <tt class="literal">AuditEntity.RevisionNumber</tt> you can specify constraints, projections
					and order on the revision number, in which the audited entity was modified
				</p></li><li><p>
					Similarly, using <tt class="literal">AuditEntity.RevisionProperty(propertyName)</tt> you can specify constraints,
					projections and order on a property of the revision entity, corresponding to the revision
					in which the audited entity was modified
				</p></li><li><p>
					<tt class="literal">AuditEntity.RevisionType</tt> gives you access as above to the type of
					the revision (ADD, MOD, DEL).
				</p></li></ol></div><p>
			Using these methods,
			you can order the query results by revision number, set projection or constraint
			the revision number to be greater or less than a specified value, etc. For example, the
			following query will select the smallest revision number, at which entity of class
			<tt class="literal">MyEntity</tt> with id <tt class="literal">entityId</tt> has changed, after revision
			number 42:
		</p><pre class="programlisting">var revision = AuditReader().CreateQuery()
	 .ForRevisionsOfEntity(typeof(MyEntity), false, true)
	 .SetProjection(AuditEntity.RevisionNumber().Min())
	 .Add(AuditEntity.Id().Eq(entityId))
	 .Add(AuditEntity.RevisionNumber().Gt(42))
	 .GetSingleResult();</pre><p>
			The second additional feature you can use in queries for revisions is the ability
			to maximalize/minimize a property. For example, if you want to select the
			revision, at which the value of the <tt class="literal">actualDate</tt> for a given entity
			was larger then a given value, but as small as possible:
		</p><pre class="programlisting">var revision = AuditReader().CreateQuery()
	 .ForRevisionsOfEntity(typeof(MyEntity), false, true)
	 // We are only interested in the first revision
	 .AddProjection(AuditEntity.RevisionNumber().Min())
	 .Add(AuditEntity.Property("actualDate").Minimize()
		  .Add(AuditEntity.Property("actualDate").Ge(givenDate))
		  .Add(AuditEntity.Id().Eq(givenEntityId)))
	 .GetSingleResult();</pre><p>
			The <tt class="literal">Minimize()</tt> and <tt class="literal">Maximize()</tt> methods return a criteria,
			to which you can add constraints, which must be met by the entities with the
			maximized/minimized properties. <tt class="literal">AggregatedAuditExpression#computeAggregationInInstanceContext()</tt>
			enables the possibility to compute aggregated expression in the context of each entity instance
			separately. It turns out useful when querying for latest revisions of all entities of a particular type.
		</p><p>
			You probably also noticed that there are two boolean parameters, passed when
			creating the query. The first one, <tt class="literal">selectEntitiesOnly</tt>, is only valid when
			you don't set an explicit projection. If true, the result of the query will be
			a list of entities (which changed at revisions satisfying the specified
			constraints).
		</p><p>
			If false, the result will be a list of three element arrays. The
			first element will be the changed entity instance. The second will be an entity
			containing revision data (if no custom entity is used, this will be an instance
			of <tt class="literal">DefaultRevisionEntity</tt>). The third will be the type of the
			revision (one of the values of the <tt class="literal">RevisionType</tt> enumeration:
			ADD, MOD, DEL).
		</p><p>
			The second parameter, <tt class="literal">selectDeletedEntities</tt>, specifies if revisions,
			in which the entity was deleted should be included in the results. If yes, such entities
			will have the revision type DEL and all fields, except the id,
			<tt class="literal">null</tt>.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="envers-envers-tracking-properties-changes-queries"></a>5.3.&nbsp;Querying for revisions of entity that modified given property</h2></div></div><div></div></div><p>
			For the two types of queries described above it's possible to use
			special Audit criteria called
			<tt class="literal">HasChanged()</tt>
			and
			<tt class="literal">HasNotChanged()</tt>
			that makes use of the functionality
			described in <a href="#envers-tracking-properties-changes" title="4.2.&nbsp;Tracking entity changes at property level">Section&nbsp;4.2, &#8220;Tracking entity changes at property level&#8221;</a>.
			They're best suited for vertical queries,
			however existing API doesn't restrict their usage for horizontal
			ones.

			Let's have a look at following examples:
		</p><pre class="programlisting">var query = AuditReader().CreateQuery()
	.ForRevisionsOfEntity(typeof(MyEntity), false, true)
	.Add(AuditEntity.Id().Eq(id))
	.Add(AuditEntity.Property("ActualDate").HasChanged());</pre><p>
			This query will return all revisions of MyEntity with given id,
			where the
			<span class="property">ActualDate</span>
			property has been changed.
			Using this query we won't get all other revisions in which
			<span class="property">ActualDate</span>
			wasn't touched. Of course nothing prevents user from combining
			HasChanged condition with some additional criteria - add method
			can be used here in a normal way.
		</p><pre class="programlisting">var query = AuditReader().CreateQuery()
	.ForEntitiesAtRevision(MyEntity.class, revisionNumber)
	.Add(AuditEntity.Property("Prop1").HasChanged())
	.Add(AuditEntity.Property("Prop2").HasNotChanged());</pre><p>
			This query will return horizontal slice for MyEntity at the time
			revisionNumber was generated. It will be limited to revisions
			that modified
			<span class="property">Prop1</span>
			but not <span class="property">Prop2</span>.
			Note that the result set will usually also contain revisions
			with numbers lower than the revisionNumber, so we cannot read
			this query as "Give me all MyEntities changed in revisionNumber
			with
			<span class="property">Prop1</span>
			modified and
			<span class="property">Prop2</span>
			untouched". To get such result we have to use the
			<tt class="literal">ForEntitiesModifiedAtRevision</tt> query:
		</p><pre class="programlisting">var query = AuditReader().CreateQuery()
	.ForEntitiesModifiedAtRevision(MyEntity.class, revisionNumber)
	.Add(AuditEntity.Property("Prop1").HasChanged())
	.Add(AuditEntity.Property("Prop2").HasNotChanged());</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="envers-tracking-modified-entities-queries"></a>5.4.&nbsp;Querying for entities modified in a given revision</h2></div></div><div></div></div><p>
			The basic query allows retrieving entity names and corresponding CLR classes changed in a specified revision:
		</p><pre class="programlisting">ISet&lt;Pair&lt;string,Type&gt;&gt; modifiedEntityTypes = AuditReader()
	.CrossTypeRevisionChangesReader().FindEntityTypes(revisionNumber);</pre><p>
			Other queries (accessible from <tt class="interfacename">NHibernate.Envers.ICrossTypeRevisionChangesReader</tt>):
		</p><div class="orderedlist"><ol type="1"><li><i class="firstterm">
					<tt class="methodname">IEnumerable&lt;object&gt; FindEntitiesChangedInRevision(Number)</tt>
				</i>
				- Returns snapshots of all audited entities changed (added, updated and removed) in a given revision.
				Executes <tt class="literal">n+1</tt> SQL queries, where <tt class="literal">n</tt> is a number of different entity
				classes modified within specified revision.
			</li><li><i class="firstterm">
					<tt class="methodname">IEnumerable&lt;object&gt; FindEntitiesChangedInRevision(Number, RevisionType)</tt>
				</i>
				- Returns snapshots of all audited entities changed (added, updated or removed) in a given revision
				filtered by modification type. Executes <tt class="literal">n+1</tt> SQL queries, where <tt class="literal">n</tt>
				is a number of different entity classes modified within specified revision.
			</li><li><i class="firstterm">
					<tt class="methodname">IDictionary&lt;RevisionType, IEnumerable&lt;object&gt;&gt; FindEntitiesChangedInRevisionGroupByRevisionType(long)</tt>
				</i>
				- Returns a map containing lists of entity snapshots grouped by modification operation (e.g.
				addition, update and removal). Executes <tt class="literal">3n+1</tt> SQL queries, where <tt class="literal">n</tt>
				is a number of different entity classes modified within specified revision.
			</li></ol></div><p>
			Note that methods described above can be legally used only when default mechanism of
			tracking changed entity names is enabled (see <a href="#envers-tracking-modified-entities-revchanges" title="4.1.&nbsp;Tracking entity names modified during revisions">Section&nbsp;4.1, &#8220;Tracking entity names modified during revisions&#8221;</a>).
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="session-extension-method"></a>5.5.&nbsp;
			<tt class="literal">Auditer()</tt>, an extension method on <tt class="literal">ISession</tt>
		</h2></div></div><div></div></div><p>
			The extension method <tt class="literal">Auditer()</tt> offers an alternative API to query Envers.

			</p><pre class="programlisting">IEnumerable&lt;long&gt; example = session.Auditer().GetRevisions&lt;MyEntity&gt;(id);</pre><p>
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="schema"></a>Chapter&nbsp;6.&nbsp;Database schema</h2></div></div><div></div></div><p>
		If following entities are audited,
	</p><pre class="programlisting">public class Address
{
	public virtual int Id {get;set;}
	public virtual int FlatNumber {get;set;}
	public virtual int HouseNumber {get;set;}
	public virtual string StreetName {get;set;}
}
	
public class Person
{
	public virtual int Id {get;set;}
	public virtual string Name {get;set;}
	public virtual string Surname {get;set;}
	public virtual Address Address {get;set;}
}</pre><p>
		we will need the following schema:
	</p><pre class="programlisting">create table Address (
	id integer generated by default as identity (start with 1),
	flatNumber integer,
	houseNumber integer,
	streetName varchar(255),
	primary key (id)
);

create table Address_AUD (
	id integer not null,
	REV integer not null,
	flatNumber integer,
	houseNumber integer,
	streetName varchar(255),
	REVTYPE tinyint not null,
	primary key (id, REV)
);

create table Person (
	id integer generated by default as identity (start with 1),
	name varchar(255),
	surname varchar(255),
	address_id integer,
	primary key (id)
);

create table Person_AUD (
	id integer not null,
	REV integer not null,
	name varchar(255),
	surname varchar(255),
	REVTYPE tinyint not null,
	address_id integer,
	primary key (id, REV)
);

create table REVINFO (
	REV integer generated by default as identity (start with 1),
	REVTSTMP bigint,
	primary key (REV)
);

alter table Person
	add constraint FK8E488775E4C3EA63
	foreign key (address_id)
	references Address;</pre></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tables"></a>Chapter&nbsp;7.&nbsp;Generated tables and their content</h2></div></div><div></div></div><p>
        For each audited entity (that is, for each entity containing at least one audited field), an audit
        table is created. By default, the audit table's name is created by adding a "_AUD" suffix to
        the original name, but this can be overriden by specifing a different suffix/prefix
        (see <a href="#configuration" title="Chapter&nbsp;3.&nbsp;Configuration">Chapter&nbsp;3, <i>Configuration</i></a>) or on a per-entity basis using the
        <tt class="literal">[AuditTable]</tt> attribute.
    </p><p>
        The audit table has the following fields:
    </p><div class="orderedlist"><ol type="1"><li><p>
                Id of the original entity (this can be more then one column, if using an embedded or multiple id)
            </p></li><li><p>
                Revision number - an integer
            </p></li><li><p>
                Revision type - a small integer
            </p></li><li><p>
                Audited fields from the original entity
            </p></li></ol></div><p>
        The primary key of the audit table is the combination of the original id of the
        entity and the revision number - there can be at most one historic entry for a given
        entity instance at a given revision.
    </p><p>
        The current entity data is stored in the original table and in the audit table.
        This is a duplication of data, however as this solution makes the query system much more
        powerful, and as storage is cheap, hopefully this won't be a major drawback for the users.
        A row in the audit table with entity id ID, revision N and data D means:
        entity with id ID has data D from revision N upwards. Hence, if we want to find an
        entity at revision M, we have to search for a row in the audit table, which has the
        revision number smaller or equal to M, but as large as possible. If no such row is
        found, or a row with a "deleted" marker is found, it means that the entity didn't
        exist at that revision.
    </p><p>
        The "revision type" field can currently have three values: 0, 1, 2, which means,
        respectively, ADD, MOD and DEL. A row with a revision of type DEL will only contain the
        id of the entity and no data (all fields NULL), as it only serves as a marker saying
        "this entity was deleted at that revision".
    </p><p>
        Additionaly, there is a "REVINFO" table generated, which contains only two fields:
        the revision id and revision timestamp. A row is inserted into this table on each
        new revision, that is, on each commit of a transaction, which changes audited data.
        The name of this table can be configured, as well as additional content stored,
        using the <tt class="literal">[RevisionEntity]</tt> attribute, see <a href="#revisionlog" title="Chapter&nbsp;4.&nbsp;Logging data for revisions">Chapter&nbsp;4, <i>Logging data for revisions</i></a>.
    </p><p>
        While global revisions are a good way to provide correct auditing of relations,
        some people have pointed out that this may be a bottleneck in systems, where data
        is very often modified. One viable solution is to introduce an option to have an
        entity "locally revisioned", that is revisions would be created for it independently.
        This wouldn't enable correct versioning of relations, but wouldn't also require the
        "REVINFO" table. Another possibility if to have "revisioning groups", that is groups
        of entities which share revision numbering. Each such group would have to consist
        of one or more strongly connected component of the graph induced by relations between
        entities. Your opinions on the subject are very welcome on the forum! :)
    </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="source"></a>Chapter&nbsp;8.&nbsp;Building from source and testing</h2></div></div><div></div></div><p>
		You can clone the source code
		<a href="https://github.com/nhibernate/nhibernate-envers" target="_top">from github</a>.
	</p><p>
		A configuration template for tests, hibernate.cfg.xml.template, can be found
		in the root folder of the tests. Copy this file and rename it to hibernate.cfg.xml
		and point to a database of your choice.
	</p><p>
		The test data is in most cases created in the "initialize" method (which is called once before
		the tests from this class are executed), which normally creates a couple of revisions,
		by persisting and updating entities. The tests first check if the revisions, in which
		entities where modified are correct (the testRevisionCounts method), and if the historic
		data is correct (the testHistoryOfXxx methods).
	</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="exceptions"></a>Chapter&nbsp;9.&nbsp;Mapping exceptions</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="exceptions-wontbesupported"></a>9.1.&nbsp;What is not and will (probably) not be supported</h2></div></div><div></div></div><p>
            Bags (the corresponding CLR type is IList&lt;T&gt;) with duplicate elements.
            The reason is that persisting, for example a bag of string-s, violates a principle
            of relational databases: that each table is a set of tuples. In case of bags,
            however (which require a join table), if there is a duplicate element, the two
            tuples corresponding to the elements will be the same. NHibernate allows this,
            however Envers (or more precisely: the database connector) will throw an exception
            when trying to persist two identical elements, because of a unique constraint violation.
        </p><p>
            There are at least two ways out if you need bag semantics:
        </p><div class="orderedlist"><ol type="1"><li><p>
                    Use an indexed collection, or
                </p></li><li><p>
                    Provide a unique id for your elements.
                </p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="exceptions-willbesupported"></a>9.2.&nbsp;What is not but <span class="emphasis"><em>will</em></span> be supported</h2></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>
					  ManyToAny reference
				  </p></li></ol></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="links"></a>Chapter&nbsp;10.&nbsp;Links</h2></div></div><div></div></div><p>
        Some useful links:
    </p><div class="orderedlist"><ol type="1"><li><p>
                <a href="http://stackoverflow.com/questions/tagged/nhibernate-envers" target="_top">User questions</a>
            </p></li><li><p>
                <a href="https://github.com/nhibernate/nhibernate-envers" target="_top">Source code</a>
            </p></li><li><p>
                <a href="http://nuget.org/packages/NHibernate.Envers" target="_top">Nuget package</a>
            </p></li><li><p>
				<a href="https://envers.bitbucket.io" target="_top">Latest documentation</a>
			</p></li></ol></div></div></div></body></html>